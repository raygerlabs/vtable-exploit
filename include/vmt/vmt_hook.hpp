#ifndef M_VMT_HOOK_HPP
#define M_VMT_HOOK_HPP

#include <cstdint>
#include <cstring>
#include <iostream>
#include <unordered_map>
#include <vector>

namespace ctf
{

/**
* @brief This class is responsible for hooking functions to specific entries in a virtual method table.
* Note: It's unsafe! 
*/
class vmt_hook
{
public:
  // type aliases
  using instance_handle = void*; /** represents the address of a class instance type */

  using vtable_entry = std::uintptr_t; /** represents an entry within the virtual method table */
  using vtable_pointer = vtable_entry*; /** represents a pointer to an entry within the virtual method table */
  using const_vtable_pointer = const vtable_entry*; /** represents a constant pointer to an entry within a virtual method table */
  using vtable_storage = std::vector<vtable_entry>; /** represents a storage area for the virtual method table in the process' address space */

  using size_type = std::size_t; /** represents size type */ 
  using index_type = size_type; /** represents indexing type */
  using hook_map = std::unordered_map<index_type, vtable_entry>; /** represents a map between index in the virtual method table and the entry in the virtual method table */

private:
  enum : std::size_t
  {
    page_size = 4096
  };
  instance_handle m_instance;
  vtable_pointer m_backupped_vtable;
  vtable_storage m_hooked_vtable{page_size};
  hook_map m_hooks;

public:
  // constructors
  explicit vmt_hook(instance_handle instance);
  vmt_hook(vmt_hook&&) noexcept = default;  // move-only
  vmt_hook& operator=(vmt_hook&&) noexcept = default;
  vmt_hook(const vmt_hook&) = delete;  // disable copying
  vmt_hook& operator=(const vmt_hook&) = delete;
  ~vmt_hook();

  // accessors
  bool is_hooked() const noexcept;
  size_type hook_count() const noexcept;

  // mutators
  template<typename TFunction>
  void hook(size_type index, TFunction&& function);
  void unhook(size_type index);
  void unhook_all();
};

inline vmt_hook::vmt_hook(instance_handle instance)
    : m_instance(instance)
    , m_backupped_vtable(*reinterpret_cast<vtable_pointer*>(instance))
{
  std::cout << ".. vtable is located at " << std::hex << instance << "\n";
  std::memcpy(m_hooked_vtable.data(), m_backupped_vtable, m_hooked_vtable.size() * sizeof(vtable_entry));
}

inline vmt_hook::~vmt_hook()
{
  unhook_all();
}

template<typename TFunction>
inline void vmt_hook::hook(size_type index, TFunction&& function)
{
  std::cout << ".. adding hook " << std::hex << m_hooked_vtable[index] << " for " << m_backupped_vtable[index] << " at "
            << std::dec << index << "\n";
  auto function_address = reinterpret_cast<vtable_entry>(function);
  m_hooked_vtable[index] = function_address;
  *reinterpret_cast<instance_handle*>(m_instance) = m_hooked_vtable.data();
  m_hooks[index] = function_address;
}

inline void vmt_hook::unhook(size_type index)
{
  std::cout << ".. removing hook " << std::hex << m_hooked_vtable[index] << " for " << m_backupped_vtable[index]
            << " at " << std::dec << index << "\n";
  m_hooked_vtable[index] = m_backupped_vtable[index];
  m_hooks.erase(index);
  if (m_hooks.empty())
  {
    *reinterpret_cast<instance_handle*>(m_instance) = m_backupped_vtable;
  }
}

inline void vmt_hook::unhook_all()
{
  for (auto&& hook : m_hooks)
  {
    m_hooked_vtable[hook.first] = m_backupped_vtable[hook.first];
  }
  m_hooks.clear();
  *reinterpret_cast<instance_handle*>(m_instance) = m_backupped_vtable;
  std::cout << ".. vtable restored at " << std::hex << m_instance << " ..\n";
}

inline bool vmt_hook::is_hooked() const noexcept
{
  return !m_hooks.empty();
}

inline typename vmt_hook::size_type vmt_hook::hook_count() const noexcept
{
  return m_hooks.size();
}

}  // namespace ctf

#endif
