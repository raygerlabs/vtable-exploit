#ifndef M_VMT_HOOK_HPP
#define M_VMT_HOOK_HPP

#include <cstdint>
#include <cstring>
#include <iostream>
#include <unordered_map>
#include <vector>

namespace ctf
{

class vmt_hook
{
public:
  using vtable_entry = std::uint64_t;
  using vtable_pointer = std::uint64_t*;
  using const_vtable_pointer = const std::uint64_t*;
  using vtable_storage = std::vector<std::uint64_t>;
  using hook_status_map = std::unordered_map<std::size_t, std::uint64_t>;
  using void_pointer = void*;
  using const_void_pointer = const void*;
  using size_type = std::size_t;

private:
  enum : std::size_t
  {
    page_size = 4096
  };
  void_pointer m_instance;
  vtable_pointer m_original_vtable;
  vtable_storage m_hooked_vtable{page_size};
  hook_status_map m_hooks;

public:
  // constructors
  explicit vmt_hook(void_pointer instance);
  vmt_hook(vmt_hook&&) noexcept = default;  // move-only
  vmt_hook& operator=(vmt_hook&&) noexcept = default;
  vmt_hook(const vmt_hook&) = delete;  // disable copying
  vmt_hook& operator=(const vmt_hook&) = delete;
  ~vmt_hook();

  // accessors
  bool is_hooked() const noexcept;
  size_type hook_count() const noexcept;

  // mutators
  template<typename TFunction>
  void hook(size_type index, TFunction&& function);
  void unhook(size_type index);
  void unhook_all();
};

inline vmt_hook::vmt_hook(void_pointer instance)
    : m_instance(instance)
    , m_original_vtable(*reinterpret_cast<vtable_pointer*>(instance))
{
  std::cout << ".. vtable is located at " << std::hex << instance << "\n";
  std::memcpy(m_hooked_vtable.data(), m_original_vtable, m_hooked_vtable.size() * sizeof(vtable_entry));
}

inline vmt_hook::~vmt_hook()
{
  unhook_all();
}

template<typename TFunction>
inline void vmt_hook::hook(size_type index, TFunction&& function)
{
  std::cout << ".. adding hook " << std::hex << m_hooked_vtable[index] << " for " << m_original_vtable[index] << " at " << std::dec << index << "\n";
  auto function_address = reinterpret_cast<vtable_entry>(function);
  m_hooked_vtable[index] = function_address;
  *reinterpret_cast<void_pointer*>(m_instance) = m_hooked_vtable.data();
  m_hooks[index] = function_address;
}

inline void vmt_hook::unhook(size_type index)
{
  std::cout << ".. removing hook " << std::hex << m_hooked_vtable[index] << " for " << m_original_vtable[index] << " at " << std::dec << index << "\n";
  m_hooked_vtable[index] = m_original_vtable[index];
  m_hooks.erase(index);
  if (m_hooks.empty())
  {
    *reinterpret_cast<void_pointer*>(m_instance) = m_original_vtable;
  }
}

inline void vmt_hook::unhook_all()
{
  for (auto&& hook : m_hooks)
  {
    m_hooked_vtable[hook.first] = m_original_vtable[hook.first];
  }
  m_hooks.clear();
  *reinterpret_cast<void_pointer*>(m_instance) = m_original_vtable;
  std::cout << ".. vtable restored at " << std::hex << m_instance << " ..\n";
}

inline bool vmt_hook::is_hooked() const noexcept
{
  return !m_hooks.empty();
}

inline typename vmt_hook::size_type vmt_hook::hook_count() const noexcept
{
  return m_hooks.size();
}

}  // namespace ctf

#endif
